{#-

  Jinja2 Template for multile dynamic files

  See odk.py for how this is processed.

  This is first expanded into a single text file;
  Each entry starting with ^^^ denotes a single file

-#}
{#-

  Ontology source file, e.g. src/ontology/foo-edit.owl

  We seed this with basic info such as ontology IRI and
  a fake root class (this can be customized).

  Note that when running odk.py, you can pass in a --source
  argument to substitute this with your own edit file

#}
^^^ src/ontology/{{ project.id }}-edit.{{ project.edit_format }}
{% if project.edit_format == "obo" %}
{% if project.import_group is defined -%}
{% for imp in project.import_group.products %}
import: http://purl.obolibrary.org/obo/{{ project.id }}/imports/{{ imp.id }}_import.owl
{% endfor %}
{% endif %}
{%- if project.use_dosdps %}
import: http://purl.obolibrary.org/obo/{{ project.id }}/patterns/definitions.owl
{%- if project.import_pattern_ontology %}
import: http://purl.obolibrary.org/obo/{{ project.id }}/patterns/pattern.owl
{% endif -%}
{% endif %}
ontology: {{project.id}}
property_value: http://purl.org/dc/elements/1.1/description "{{ project.description }}" xsd:string
property_value: http://purl.org/dc/elements/1.1/title "{{ project.title }}" xsd:string
property_value: http://purl.org/dc/terms/license {{ project.license }}

[Term]
id: {{ project.id | upper }}:00000000
name: root node

{% else %}
Prefix(:=<http://purl.obolibrary.org/obo/{{ project.id }}.owl#>)
Prefix(owl:=<http://www.w3.org/2002/07/owl#>)
Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)
Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)
Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)
Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)
Prefix(dce:=<http://purl.org/dc/elements/1.1/>)
Prefix(dcterms:=<http://purl.org/dc/terms/>)


Ontology(<http://purl.obolibrary.org/obo/{{ project.id }}.owl>
{% if project.import_group is defined -%}
{% for imp in project.import_group.products %}
Import(<http://purl.obolibrary.org/obo/{{ project.id }}/imports/{{ imp.id }}_import.owl>)
{% endfor %}
{% endif %}

{%- if project.use_dosdps %}
Import(<http://purl.obolibrary.org/obo/{{ project.id }}/patterns/definitions.owl>)
{%- if project.import_pattern_ontology %}
Import(<http://purl.obolibrary.org/obo/{{ project.id }}/patterns/pattern.owl>)
{% endif -%}
{% endif %}

Annotation(dce:title "{{ project.title }}")
Annotation(dcterms:license <{{ project.license }}>)
Annotation(dce:description "{{ project.description }}")

Declaration(Class(<http://purl.obolibrary.org/obo/{{ project.id | upper }}_00000000>))


############################
#   Classes
############################

# Class: <http://purl.obolibrary.org/obo/{{ project.id | upper }}_00000000>

AnnotationAssertion(rdfs:label <http://purl.obolibrary.org/obo/{{ project.id | upper }}_00000000> "root node"@en)


)
{% endif %}
{#-

  ID ranges file

#}
^^^ src/ontology/{{ project.id }}-idranges.owl
## ID Ranges File
Prefix: rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
Prefix: idsfor: <http://purl.obolibrary.org/obo/IAO_0000598>
Prefix: dc: <http://purl.org/dc/elements/1.1/>
Prefix: xsd: <http://www.w3.org/2001/XMLSchema#>
Prefix: allocatedto: <http://purl.obolibrary.org/obo/IAO_0000597>
Prefix: xml: <http://www.w3.org/XML/1998/namespace>
Prefix: idprefix: <http://purl.obolibrary.org/obo/IAO_0000599>
Prefix: iddigits: <http://purl.obolibrary.org/obo/IAO_0000596>
Prefix: rdfs: <http://www.w3.org/2000/01/rdf-schema#>
Prefix: idrange: <http://purl.obolibrary.org/obo/ro/idrange/>
Prefix: owl: <http://www.w3.org/2002/07/owl#>

Ontology: <http://purl.obolibrary.org/obo/{{ project.id }}/{{ project.id }}-idranges.owl>


Annotations: 
    idsfor: "{{ project.id | upper }}",
    idprefix: "http://purl.obolibrary.org/obo/{{ project.id | upper }}_",
    iddigits: 7

AnnotationProperty: idprefix:

    
AnnotationProperty: iddigits:

    
AnnotationProperty: idsfor:

    
AnnotationProperty: allocatedto:

Datatype: idrange:1

    Annotations: 
        allocatedto: "ONTOLOGY-CREATOR"
    
    EquivalentTo: 
        xsd:integer[>= 0 , <= 999999]

    
Datatype: idrange:2

    Annotations: 
        allocatedto: "ADDITIONAL EDITOR"
    
    EquivalentTo: 
        xsd:integer[>= 1000000 , <= 1999999]
    
    
Datatype: xsd:integer
Datatype: rdf:PlainLiteral

^^^ src/ontology/{{ project.id }}.Makefile
## Customize Makefile settings for {{project.id}}
## 
## If you need to customize your Makefile, make
## changes here rather than in the main Makefile
{% if project.import_group is defined -%}
{%- if 'custom' == project.import_group.module_type %}
imports/%_import.owl: mirror/%.owl
	echo "ERROR: You have configured your default module type to be custom; this behavior needs to be overwritten in {{ project.id }}.Makefile!" && touch $@
{% endif %}
{%- endif %}
{#-

  Imports files, one per import

#}
{% for imp in project.import_group.products %}
^^^ src/ontology/imports/{{ imp.id }}_import.owl
<?xml version="1.0"?>
<rdf:RDF 
     xml:base="http://purl.obolibrary.org/obo/"
     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
     xmlns:owl="http://www.w3.org/2002/07/owl#"
     xmlns:oboInOwl="http://www.geneontology.org/formats/oboInOwl#"
     xmlns:xml="http://www.w3.org/XML/1998/namespace"
     xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
     xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
     xmlns:obo="http://purl.obolibrary.org/obo/">
    <owl:Ontology rdf:about="{{ project.uribase }}/{{ project.id }}/imports/{{ imp.id }}_import.owl"/>

    <!-- This is a placeholder, it will be regenerated when makefile is first executed -->
</rdf:RDF>
{#-

  Import Term files

  We seed each of these with some random terms. This is a little unsatisfactory and fragile;
  ROBOT extract will fail if it cannot find any of the terms. While this doesn't matter in the long term,
  as the ontology maintainer will provide their own lists, but it is problematic for the initial seed.

  TODO: Decide if we should either query ontobee for seed terms OR have the seed list provided in the project.yaml

#}
^^^ src/ontology/imports/{{ imp.id }}_terms.txt
{% endfor %}
{#-

  Metadata files.

  These are convenient for submission to OBO. Note that OBO maintains two files, a .md and a .yml

  TODO: include a script that makes it easy for maintainers to do this.

#}
{%- if project.create_obo_metadata %}
^^^ src/metadata/README.md
Metadata files for the OBO Library

 * [{{ project.id }}.yml]({{ project.id }}.yml)
     * Determines how your purl.obolibrary.org/obo/{{ project.id }}/ redirects will be handled
     * Go here: https://github.com/OBOFoundry/purl.obolibrary.org/tree/master/config
     * Click [New File](https://github.com/OBOFoundry/purl.obolibrary.org/new/master/config)
     * Paste in the contents of [{{ project.id }}.yml]({{ project.id }}.yml)
     * Click "Commit new file"
     * IMPORTANT: remember to make a pull request
     * An OBO admin will merge your Pull Request *providing it meets the requirements of the OBO library*
 * [{{ project.id }}.md]({{ project.id }}.md)
     * Determines how your metadata is shown on OBO Library, OLS and AberOWL
     * Go here: https://github.com/OBOFoundry/OBOFoundry.github.io/tree/master/ontology
     * Click [New File](https://github.com/OBOFoundry/OBOFoundry.github.io/new/master/ontology)
     * Paste in the contents of [{{ project.id }}.md]({{ project.id }}.md)
     * Click "Commit new file"
     * IMPORTANT: remember to make a pull request
     * An OBO admin will merge your Pull Request *providing it meets the requirements of the OBO library*
     
For more background see:

 * http://obofoundry.org/
 * http://obofoundry.org/faq/how-do-i-edit-metadata.html

^^^ src/metadata/{{ project.id }}.md
---
layout: ontology_detail
id: {{ project.id }}
title: {{ project.title }}
jobs:
  - id: https://travis-ci.org/{{ project.github_org }}/{{ project.repo }}
    type: travis-ci
build:
  checkout: git clone https://github.com/{{ project.github_org }}/{{ project.repo }}.git
  system: git
  path: "."
contact:
  email: {{ project.contact.email }}
  label: {{ project.contact.name }}
  github: {{ project.contact.github }}
description: {{ project.title }} is an ontology...
domain: stuff
homepage: https://github.com/{{ project.github_org }}/{{ project.repo }}
products:
  - id: {{ project.id }}.owl
    name: "{{ project.title }} main release in OWL format"
  - id: {{ project.id }}.obo
    name: "{{ project.title }} additional release in OBO format"
  - id: {{ project.id }}.json
    name: "{{ project.title }} additional release in OBOJSon format"
  - id: {{ project.id }}/{{ project.id }}-base.owl
    name: "{{ project.title }} main release in OWL format"
  - id: {{ project.id }}/{{ project.id }}-base.obo
    name: "{{ project.title }} additional release in OBO format"
  - id: {{ project.id }}/{{ project.id }}-base.json
    name: "{{ project.title }} additional release in OBOJSon format"
dependencies:
{% for imp in project.import_group.products -%}
- id: {{ imp.id }}
{% endfor %}
tracker: https://github.com/{{ project.github_org }}/{{ project.repo }}/issues
license:
  url: http://creativecommons.org/licenses/by/3.0/
  label: CC-BY
activity_status: active
---

Enter a detailed description of your ontology here. You can use arbitrary markdown and HTML.
You can also embed images too.

^^^ src/metadata/{{ project.id }}.yml
# PURL configuration for http://purl.obolibrary.org/obo/{{ project.id }}

idspace: {{ project.id|upper }}
base_url: /obo/{{ project.id }}

products:
- {{ project.id }}.owl: https://raw.githubusercontent.com/{{ project.github_org }}/{{ project.repo }}/{{ project.git_main_branch }}/{{ project.id }}.owl
- {{ project.id }}.obo: https://raw.githubusercontent.com/{{ project.github_org }}/{{ project.repo }}/{{ project.git_main_branch }}/{{ project.id }}.obo

term_browser: ontobee
example_terms:
- {{ project.id.upper() }}_0000000

entries:

- prefix: /releases/
  replacement: https://raw.githubusercontent.com/{{ project.github_org }}/{{ project.repo }}/v

- prefix: /tracker/
  replacement: https://github.com/{{ project.github_org }}/{{ project.repo }}/issues

- prefix: /about/
  replacement: http://www.ontobee.org/ontology/{{ project.id|upper }}?iri=http://purl.obolibrary.org/obo/

## generic fall-through, serve direct from github by default
- prefix: /
  replacement: https://raw.githubusercontent.com/{{ project.github_org }}/{{ project.repo }}/{{ project.git_main_branch }}/
{%- endif %}
{#-
    Example pattern implementation TSV
#}
{%- if project.use_dosdps %}
^^^ src/patterns/definitions.owl
Prefix(:=<http://purl.obolibary.org/obo/{{ project.id }}/definitions.owl#>)
Prefix(owl:=<http://www.w3.org/2002/07/owl#>)
Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)
Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)
Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)
Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)


Ontology(<http://purl.obolibary.org/obo/{{ project.id }}/definitions.owl>

)
^^^ src/patterns/pattern.owl
Prefix(:=<http://purl.obolibary.org/obo/{{ project.id }}/pattern.owl#>)
Prefix(owl:=<http://www.w3.org/2002/07/owl#>)
Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)
Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)
Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)
Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)


Ontology(<http://purl.obolibary.org/obo/{{ project.id }}/pattern.owl>

)
^^^ src/patterns/README.md
# DOSDP patterns - editors docs
^^^ src/patterns/data/default/example.tsv
defined_class	example

^^^ src/patterns/dosdp-patterns/example.yaml
pattern_name: example
pattern_iri: http://purl.obolibrary.org/obo/{{ project.id }}/example.yaml
description: "This is a minimal example pattern."

classes:
  example: owl:Thing

relations:
  part_of: BFO:0000050

vars:
  example: "'example'"

name:
  text: "Part of %s"
  vars:
   - example

equivalentTo:
  text: "'part_of' some %s"
  vars:
    - example
^^^ src/patterns/dosdp-patterns/external.txt
^^^ src/patterns/data/default/README.md
Documentation of the Default DOSDP Pipeline
{%- if project.pattern_pipelines_group is defined %}
{%- for pipeline in project.pattern_pipelines_group.products %}
^^^ src/patterns/data/{{ pipeline.id }}/README.md
# Documentation of the {{ pipeline.id }} DOSDP Pipeline
{%- endfor %}
{%- endif %}
{%- endif %}
{#-
    SPARQL QUERY to collect all terms that belong to an ontology
#}
^^^ src/sparql/{{ project.id }}_terms.sparql
SELECT DISTINCT ?term
WHERE {
  { ?s1 ?p1 ?term . }
  UNION
  { ?term ?p2 ?o2 . }
  FILTER(isIRI(?term) && (regex(str(?term), UCASE("{{ project.id }}_")){% if project.namespaces %}{% for ns in project.namespaces %} || regex(str(?term), "{{ ns }}"){% endfor %}{% endif %}))
}
{%- if project.components is defined %}
{%- for component in project.components.products %}
^^^ src/ontology/components/{{ component.filename }}
<?xml version="1.0"?>
<rdf:RDF 
     xml:base="http://purl.obolibrary.org/obo/"
     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
     xmlns:owl="http://www.w3.org/2002/07/owl#"
     xmlns:oboInOwl="http://www.geneontology.org/formats/oboInOwl#"
     xmlns:xml="http://www.w3.org/XML/1998/namespace"
     xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
     xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
     xmlns:obo="http://purl.obolibrary.org/obo/">
    <owl:Ontology rdf:about="{{ project.uribase }}/{{ project.id }}/components/{{ component.filename }}"/>

    <!-- This is a placeholder, it will be regenerated when makefile is first executed -->
</rdf:RDF>
{%- endfor %}
{%- endif %}
{%- if project.robot_report.custom_profile %}
^^^ src/ontology/profile.txt
WARN	annotation_whitespace
ERROR	deprecated_boolean_datatype
ERROR	deprecated_class_reference
ERROR	deprecated_property_reference
ERROR	duplicate_definition
WARN	duplicate_exact_synonym
WARN	duplicate_label_synonym
ERROR	duplicate_label
WARN	duplicate_scoped_synonym
WARN	equivalent_pair
WARN	invalid_xref
ERROR	label_formatting
ERROR	label_whitespace
INFO	lowercase_definition
WARN	missing_definition
ERROR	missing_label
WARN	missing_obsolete_label
ERROR	missing_ontology_description
ERROR	missing_ontology_license
ERROR	missing_ontology_title
INFO	missing_superclass
ERROR	misused_obsolete_label
ERROR	multiple_definitions
ERROR	multiple_equivalent_classes
ERROR	multiple_labels
{%- endif %}
{%- if 'basic' in project.release_artefacts or project.primary_release == 'basic' %}
^^^ src/ontology/keeprelations.txt
BFO:0000050
{% endif -%}
{% if project.ci is defined -%}{% if 'travis' in project.ci %}
^^^ .travis.yml
## REMEMBER TO SET UP YOUR GIT REPO FOR TRAVIS
## Go to: https://travis-ci.org/{{ project.github_org }} for details
sudo: required

services:
  - docker

before_install:
  - docker pull obolibrary/odkfull

# command to run tests
script: cd src/ontology && sh run.sh make test

#after_success:
#  coveralls

# whitelist
branches:
  only:
    - {{ project.git_main_branch }}
    - test-travis

### Add your own lists here
### See https://github.com/INCATools/ontology-development-kit/issues/35
notifications:
  email:
    - obo-ci-reports-all@groups.io
{% endif -%}{% if 'github_actions' in project.ci %}
^^^ .github/workflows/qc.yml
# Basic ODK workflow

name: CI

# Controls when the action will run. 
on:
  # Triggers the workflow on push or pull request events but only for the {{ project.git_main_branch }} branch
  push:
    branches: [ {{ project.git_main_branch }} ]
  pull_request:
    branches: [ {{ project.git_main_branch }} ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "ontology_qc"
  ontology_qc:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    container: obolibrary/odkfull:{% if env is defined -%}{{env['ODK_VERSION'] or "v1.2.25" }}{%- else %}v1.2.25{% endif %}

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v2

      - name: Run ontology QC checks
        env:
          DEFAULT_BRANCH: {{ project.git_main_branch }}
        run: cd src/ontology && make ROBOT_ENV='ROBOT_JAVA_ARGS=-Xmx6G' test IMP=false PAT=false
{% endif -%}
{% endif -%}
{% if project.use_custom_import_module %}
^^^ src/templates/external_import.tsv
ID	Entity Type
ID	TYPE
owl:Thing	owl:Class
{% endif -%}
{% if project.documentation is not none %}
^^^ docs/index.md
# {{ project.id.upper() }} Ontology Documentation

[//]: # "This file is meant to be edited by the ontology maintainer."

Welcome to the {{ project.id.upper() }} documentation!

You can find descriptions of the standard ontology engineering workflows [here](odk-workflows/index.md).
^^^ docs/history.md
# A brief history of {{ project.id.upper() }}

The following page gives an overview of the history of {{ project.id.upper() }}.
^^^ docs/cite.md
# How to cite {{ project.id.upper() }}
^^^ docs/contributing.md
# How to contribute to {{ project.id.upper() }}
^^^ docs/odk-workflows/index.md
# Default ODK Workflows

- [Daily Editors Workflow](EditorsWorkflow.md)
- [Release Workflow](ReleaseWorkflow.md)
- [Manage your ODK Repository](RepoManagement.md)
- [Setting up Docker for ODK](SettingUpDockerForODK.md)
- [Imports management](UpdateImports.md)
- [Managing the documentation](ManageDocumentation.md)

^^^ docs/odk-workflows/ContinuousIntegration.md
# Introduction to Continuous Integration Workflows with ODK

Historically, most repos have been using Travis CI for continuous integration testing and building, but due to
runtime restrictions, we recently switched a lot of our repos to GitHub actions. You can set up your repo with CI by adding 
this to your configuration file (src/ontology/{{ project.id }}-odk.yaml):

```
ci:
  - github_actions
```

When [updateing your repo](RepoManagement.md), you will notice a new file being added: `.github/workflows/qc.yml`.

This file contains your CI logic, so if you need to change, or add anything, this is the place!

^^^ docs/odk-workflows/EditorsWorkflow.md
# Editors Workflow

The editors workflow is one of the formal [workflows](index.md) to ensure that the ontology is developed correctly according to ontology engineering principles. There are a few different editors workflows:

1. Local editing workflow: Editing the ontology in your local environment by hand, using tools such as Protégé, ROBOT templates or DOSDP patterns.
2. Completely automated data pipeline (GitHub Actions)
3. DROID workflow

This document only covers the first editing workflow, but more will be added in the future

### Local editing workflow

Workflow requirements:
- git
- github
- docker
- editing tool of choice, e.g. Protégé, your favourite text editor, etc

#### 1. _Create issue_
Ensure that there is a ticket on your issue tracker that describes the change you are about to make. While this seems optional, this is a very important part of the social contract of building an ontology - no change to the ontology should be performed without a good ticket, describing the motivation and nature of the intended change.

#### 2. _Update main branch_ 
In your local environment (e.g. your laptop), make sure you are on the `main` (prev. `master`) branch and ensure that you have all the upstream changes, for example:

```
git checkout master
git pull
```

#### 3. _Create feature branch_
Create a new branch. Per convention, we try to use meaningful branch names such as:
- issue23removeprocess (where issue 23 is the related issue on GitHub)
- issue26addcontributor
- release20210101 (for releases)

On your command line, this looks like this:

```
git checkout -b issue23removeprocess
```

#### 4. _Perform edit_
Using your editor of choice, perform the intended edit. For example:

_Protege_

1. Open `src/ontology/{{ project.id }}-edit.owl` in Protege
2. Make the change
3. Save the file

_TextEdit_

1. Open `src/ontology/{{ project.id }}-edit.owl` in TextEdit (or Sublime, Atom, Vim, Nano)
2. Make the change
3. Save the file

Consider the following when making the edit.

1. According to our development philosophy, the only places that should be manually edited are:
    - `src/ontology/{{ project.id }}-edit.owl`
    - Any ROBOT templates you chose to use (the TSV files only)
    - Any DOSDP data tables you chose to use (the TSV files, and potentially the associated patterns)
    - components (anything in `src/ontology/components`), see [here](RepositoryFileStructure.md).
2. Imports should not be edited (any edits will be flushed out with the next update). However, refreshing imports is a potentially breaking change - and is discussed [elsewhere](UpdateImports.md).
3. Changes should usually be small. Adding or changing 1 term is great. Adding or changing 10 related terms is ok. Adding or changing 100 or more terms at once should be considered very carefully.

#### 4. _Check the Git diff_
This step is very important. Rather than simply trusting your change had the intended effect, we should always use a git diff as a first pass for sanity checking.

In our experience, having a visual git client like [GitHub Desktop](https://desktop.github.com/) or [sourcetree](https://www.sourcetreeapp.com/) is really helpful for this part. In case you prefer the command line:

```
git status
git diff
```
#### 5. Quality control
Now its time to run your quality control checks. This can either happen locally ([5a](#Local-testing)) or through your continuous integration system ([7/5b](#continuous-integration-testing)).

#### 5a. Local testing
If you chose to run your test locally:

```
sh run.sh make IMP=false test
```
This will run the whole set of configured ODK tests on including your change. If you have a complex DOSDP pattern pipeline you may want to add `PAT=false` to skip the potentially lengthy process of rebuilding the patterns.

```
sh run.sh make IMP=false PAT=false test
```

#### 6. Pull request

When you are happy with the changes, you commit your changes to your feature branch, push them upstream (to GitHub) and create a pull request. For example:

```
git add NAMEOFCHANGEDFILES
git commit -m "Added biological process term #12"
git push -u origin issue23removeprocess
```

Then you go to your project on GitHub, and create a new pull request from the branch, for example: https://github.com/INCATools/ontology-development-kit/pulls

There is a lot of great advise on how to write pull requests, but at the very least you should:
- mention the tickets affected: `see #23` to link to a related ticket, or `fixes #23` if, by merging this pull request, the ticket is fixed. Tickets in the latter case will be closed automatically by Github when the pull request is merged.
- summarise the changes in a few sentences. Consider the reviewer: what would they want to know right away.
- If the diff is large, provide instructions on how to review the pull request best (sometimes, there are many changed files, but only one important change).

#### 7/5b. Continuous Integration Testing
If you didn't run and local quality control checks (see [5a](#Local-testing)), you should have Continuous Integration (CI) set up, for example:
- Travis
- GitHub Actions

More on how to set this up [here](ContinuousIntegration.md). Once the pull request is created, the CI will automatically trigger. If all is fine, it will show up green, otherwise red.

#### 8. Community review
Once all the automatic tests have passed, it is important to put a second set of eyes on the pull request. Ontologies are inherently social - as in that they represent some kind of community consensus on how a domain is organised conceptually. This seems high brow talk, but it is very important that as an ontology editor, you have your work validated by the community you are trying to serve (e.g. your colleagues, other contributors etc). In our experience, it is hard to get more than one review on a pull request - two is great. You can set up GitHub branch protection to actually require a review before a pull request can be merged! We recommend this.

This step seems daunting to some hopefully under-resourced ontologies, but we recommend to put this high up on your list of priorities - train a colleague, reach out!

#### 9. Merge and cleanup
When the QC is green and the reviews are in (approvals), it is time to merge the pull request. After the pull request is merged, remember to delete the branch as well (this option will show up as a big button right after you have merged the pull request). If you have not done so, close all the associated tickets fixed by the pull request.

#### 10. Changelog (Optional)
It is sometimes difficult to keep track of changes made to an ontology. Some ontology teams opt to document changes in a changelog (simply a text file in your repository) so that when release day comes, you know everything you have changed. This is advisable at least for major changes (such as a new release system, a new pattern or template etc).
^^^ docs/odk-workflows/ReleaseWorkflow.md
# The release workflow 
The release workflow recommended by the ODK is based on GitHub releases and works as follows:

1. Run a release with the ODK
2. Review the release
3. Merge to main branch
4. Create a GitHub release

These steps are outlined in detail in the following.

## Run a release with the ODK

Preparation:

1. Ensure that all your pull requests are merged into your main (master) branch
2. Make sure that all changes to master are committed to Github (`git status` should say that there are no modified files)
3. Locally make sure you have the latest changes from master (`git pull`)
4. Checkout a new branch (e.g. `git checkout -b release-2021-01-01`)
5. You may or may not want to refresh your imports as part of your release strategy (see [here](UpdateImports.md))
6. Make sure you have the latest ODK installed by running `docker pull obolibrary/odkfull`

To actually run the release, you:

1. Open a command line terminal window and navigate to the src/ontology directory (`cd {{ project.id }}/src/ontology`)
2. Run release pipeline:`sh run.sh make prepare_release -B`. Note that for some ontologies, this process can take up to 90 minutes - especially if there are large ontologies you depend on, like PRO or CHEBI.
3. If everything went well, you should see the following output on your machine: `Release files are now in ../.. - now you should commit, push and make a release on your git hosting site such as GitHub or GitLab`.

This will create all the specified release targets (OBO, OWL, JSON, and the variants, ont-full and ont-base) and copy them into your release directory (the top level of your repo).

## Review the release

1. (Optional) Rough check. This step is frequently skipped, but for the more paranoid among us (like the author of this doc), this is a 3 minute additional effort for some peace of mind. Open the main release ({{ project.id }}.owl) in you favourite development environment (i.e. Protege) and eyeball the hierarchy. We recommend two simple checks: 
    1. Does the very top level of the hierarchy look ok? This means that all new terms have been imported/updated correctly.
    2. Does at least one change that you know should be in this release appear? For example, a new class. This means that the release was actually based on the recent edit file. 
2. Commit your changes to the branch and make a pull request
3. In your GitHub pull request, review the following three files in detail (based on our experience):
    1. `{{ project.id }}.obo` - this reflects a useful subset of the whole ontology (everything that can be covered by OBO format). OBO format has that speaking for it: it is very easy to review!
    2. `{{ project.id }}-base.owl` - this reflects the asserted axioms in your ontology that you have actually edited.
    3. Ideally also take a look at `{{ project.id }}-full.owl`, which may reveal interesting new inferences you did not know about. Note that the diff of this file is sometimes quite large.
4. Like with every pull request, we recommend to always employ a second set of eyes when reviewing a PR!

## Merge the main branch
Once your [CI checks](ContinuousIntegration.md) have passed, and your reviews are completed, you can now merge the branch into your main branch (don't forget to delete the branch afterwards - a big button will appear after the merge is finished).

## Create a GitHub release

1. Go to your releases page on GitHub by navigating to your repository, and then clicking on releases (usually on the right, for example: https://github.com/{{ project.github_org }}/{{ project.repo }}/releases. Then click "Draft new release"
1. As the tag version you **need to choose the date on which your ontologies were build.** You can find this, for example, by looking at the `{{ project.id }}.obo` file and check the `data-version:` property. The date needs to be prefixed with a `v`, so, for example `v2020-02-06`.
1. You can write whatever you want in the release title, but we typically write the date again. The description underneath should contain a concise list of changes or term additions.
1. Click "Publish release". Done.

## Debugging typical ontology release problems

### Problems with memory

When you are dealing with large ontologies, you need a lot of memory. When you see error messages relating to large ontologies such as CHEBI, PRO, NCBITAXON, or Uberon, you should think of memory first, see [here](https://github.com/INCATools/ontology-development-kit/blob/master/docs/DealWithLargeOntologies.md).

### Problems when using OBO format based tools

Sometimes you will get cryptic error messages when using legacy tools using OBO format, such as the ontology release tool (OORT), which is also available as part of the ODK docker container. In these cases, you need to track down what axiom or annotation actually caused the breakdown. In our experience (in about 60% of the cases) the problem lies with duplicate annotations (`def`, `comment`) which are illegal in OBO. Here is an example recipe of how to deal with such a problem:

1. If you get a message like `make: *** [cl.Makefile:84: oort] Error 255` you might have a OORT error. 
2. To debug this, in your terminal enter `sh run.sh make IMP=false PAT=false oort -B` (assuming you are already in the ontology folder in your directory) 
3. This should show you where the error is in the log (eg multiple different definitions) 
WARNING: THE FIX BELOW IS NOT IDEAL, YOU SHOULD ALWAYS TRY TO FIX UPSTREAM IF POSSIBLE
4. Open `{{ project.id }}-edit.owl` in Protege and find the offending term and delete all offending issue (e.g. delete ALL definition, if the problem was "multiple def tags not allowed") and save. 
*While this is not idea, as it will remove all definitions from that term, it will be added back again when the term is fixed in the ontology it was imported from and added back in.
5. Rerun `sh run.sh make IMP=false PAT=false oort -B` and if it all passes, commit your changes to a branch and make a pull request as usual.

^^^ docs/odk-workflows/RepoManagement.md
# Managing your ODK repository

## Updating your ODK repository

Your ODK repositories configuration is managed in `src/ontology/{{ project.id }}-odk.yaml`. Once you have made your changes, you can run the following to apply your changes to the repository:


```
sh run.sh make update_repo
```

There are a large number of options that can be set to configure your ODK, but we will only discuss a few of them here.

## Managing imports

You can use the update repository worflow described on this page to perform the following operations to your imports:

1. Add a new import
2. Modify an existing import
3. Remove an import you no longer want
4. Customise an import

We will discuss all these workflows in the following.


### Add new import

To add a new import, you first edit your odk config as described [above](#Updating-your-ODK-repository), adding an `id` to the `product` list in the `import_group` section (for the sake of this example, we assume you already import RO, and your goal is to also import GO):

```
import_group:
  products:
    - id: ro
    - id: go
```

Note: our ODK file should only have one `import_group` which can contain multiple imports (in the `products` section). Next, you run the [update repo workflow](#Updating-your-ODK-repository) to apply these changes. Note that by default, this module is going to be a SLME Bottom module, see [here](http://robot.obolibrary.org/extract). To change that or customise your module, see section "Customise an import". To finalise the addition of your import, perform the following steps:

1. Add an imports statement to your `src/ontology/{{ project.id }}-edit.owl` file. We suggest to do this using a text editor, by simply copying an existing imports declaration and renaming it to the new ontology import, for example as follows:

```
...
Ontology(<http://purl.obolibrary.org/obo/{{ project.id }}.owl>
Import(<http://purl.obolibrary.org/obo/{{ project.id }}/imports/ro_import.owl>)
Import(<http://purl.obolibrary.org/obo/{{ project.id }}/imports/go_import.owl>)
...
```

2. Add your imports redirect to your catalog file `src/ontology/catalog-v001.xml`, for example:

```
<uri name="http://purl.obolibrary.org/obo/{{ project.id }}/imports/go_import.owl" uri="imports/go_import.owl"/>
```

3. Test whether everything is in order:
    1. [Refresh your import](UpdateImports.md)
    2. Open in your Ontology Editor of choice (Protege) and ensure that the expected terms are imported.

### Modify an existing import

If you simply wish to refresh your import in light of new terms, see [here](UpdateImports.md). If you wish to change the type of your module see section "Customise an import".

### Remove an existing import

To remove an existing import, perform the following steps:

1. remove the import declaration from your `src/ontology/{{ project.id }}-edit.owl`.
2. remove the id from your `src/ontology/{{ project.id }}-odk.yaml`, eg. `- id: go` from the list of `products` in the `import_group`.
3. run [update repo workflow](#Updating-your-ODK-repository)
4. delete the associated files manually:
    - `src/imports/go_import.owl`
    - `src/imports/go_terms.txt`
5. Remove the respective entry from the `src/ontology/catalog-v001.xml` file.

### Customise an import

By default, an import module extracted from a source ontology will be a SLME module, see [here](http://robot.obolibrary.org/extract). There are various options to change the default.

The following change to your repo config (`src/ontology/{{ project.id }}-odk.yaml`) will switch the go import from an SLME module to a simple ROBOT filter module:

```
import_group:
  products:
    - id: ro
    - id: go
      module_type: filter
```

A ROBOT filter module is, essentially, importing all external terms declared by the your ontology (see [here](UpdateImports.md)] on how to declare external terms to be imported). Note that the `filter` module does 
not consider terms/annotations from namespaces other than the base-namespace of the ontology itself. For example, in the
example of GO above, only annotations / axioms related to the GO base IRI (http://purl.obolibrary.org/obo/GO_) would be considered. This 
behaviour can be changed by adding additional base IRIs as follows:


```
import_group:
  products:
    - id: go
      module_type: filter
      base_iris:
        - http://purl.obolibrary.org/obo/GO_
        - http://purl.obolibrary.org/obo/CL_
        - http://purl.obolibrary.org/obo/BFO
```

If you wish to customise your import entirely, you can specify your own ROBOT command to do so. To do that, add the following to your repo config (`src/ontology/{{ project.id }}-odk.yaml`):

```
import_group:
  products:
    - id: ro
    - id: go
      module_type: custom
```

Now add a new goal in your custom Makefile (`src/ontology/{{ project.id }}.Makefile`, _not_ `src/ontology/Makefile`).

```
imports/go_import.owl: mirror/ro.owl imports/ro_terms_combined.txt
	if [ $(IMP) = true ]; then $(ROBOT) query  -i $< --update ../sparql/preprocess-module.ru \
		extract -T imports/ro_terms_combined.txt --force true --individuals exclude --method BOT \
		query --update ../sparql/inject-subset-declaration.ru --update ../sparql/postprocess-module.ru \
		annotate --ontology-iri $(ONTBASE)/$@ $(ANNOTATE_ONTOLOGY_VERSION) --output $@.tmp.owl && mv $@.tmp.owl $@; fi
```

Now feel free to change this goal to do whatever you wish it to do! It probably makes some sense (albeit not being a strict necessity), to leave most of the goal instead and replace only:

```
extract -T imports/ro_terms_combined.txt --force true --individuals exclude --method BOT \
```

to another ROBOT pipeline.

_Note_: if your mirror is particularly large and complex, read [this ODK recommendation](https://github.com/INCATools/ontology-development-kit/blob/master/docs/DealWithLargeOntologies.md).
^^^ docs/odk-workflows/RepositoryFileStructure.md
# Repository structure

The main kinds of files in the repository:

1. Release files
2. Imports
3. [Components](#Components)

## Release files
Release file are the file that are considered part of the official ontology release and to be used by the community. A detailed descripts of the release artefacts can be found [here](https://github.com/INCATools/ontology-development-kit/blob/master/docs/ReleaseArtefacts.md).

## Imports
Imports are subsets of external ontologies that contain terms and axioms you would like to re-use in your ontology. These are considered "external", like dependencies in software development, and are not included in your "base" product, which is the [release artefact](https://github.com/INCATools/ontology-development-kit/blob/master/docs/ReleaseArtefacts.md) which contains only those axioms that you personally maintain.

These are the current imports in {{ project.id.upper() }}

{% if project.import_group is defined -%}
| Import | URL | Type |
| ------ | --- | ---- |
{%- for imp in project.import_group.products %}
| {{ imp.id }} | {% if imp.mirror_from is not none %}{{ imp.mirror_from }}{% else %}http://purl.obolibrary.org/obo/{{ imp.id }}.owl{% endif %} | {% if imp.module_type is defined %}{{ imp.module_type }}{% else %}{{ project.import_group.module_type }}{% endif %} |
{%- endfor %}
{%- endif %}

## Components
Components, in contrast to imports, are considered full members of the ontology. This means that any axiom in a component is also included in the ontology base - which means it is considered _native_ to the ontology. While this sounds complicated, consider this: conceptually, no component should be part of more than one ontology. If that seems to be the case, we are most likely talking about an import. Components are often not needed for ontologies, but there are some use cases:

1. There is an automated process that generates and re-generates a part of the ontology
2. A part of the ontology is managed in ROBOT templates
3. The expressivity of the component is higher than the format of the edit file. For example, people still choose to manage their ontology in OBO format (they should not) missing out on a lot of owl features. They may chose to manage logic that is beyond OBO in a specific OWL component.

{% if project.components is not none -%}
These are the components in {{ project.id.upper() }}

| Filename | URL |
| -------- | --- |
{%- for component in project.components.products %}
| {{ component.filename }} | {% if component.source is defined %}{{ component.source }}{% endif %} |
{%- endfor %}
{%- endif %}
^^^ docs/odk-workflows/SettingUpDockerForODK.md
# Setting up your Docker environment for ODK use

One of the most frequent problems with running the ODK for the first time is failure because of lack of memory. This can look like a Java OutOfMemory exception, 
but more often than not it will appear as something like an `Error 137`. There are two places you need to consider to set your memory:

1. Your src/ontology/run.sh (or run.bat) file. You can set the memory in there by adding 
`robot_java_args: '-Xmx8G'` to your src/ontology/{{ project.id }}-odk.yaml file, see for example [here](https://github.com/INCATools/ontology-development-kit/blob/0e0aef2b26b8db05f5e78b7c38f807d04312d06a/configs/uberon-odk.yaml#L36).
2. Set your docker memory. By default, it should be about 10-20% more than your `robot_java_args` variable. You can manage your memory settings
by right-clicking on the docker whale in your system bar-->Preferences-->Resources-->Advanced, see picture below.

![dockermemory](https://github.com/INCATools/ontology-development-kit/raw/master/docs/img/docker_memory.png)


^^^ docs/odk-workflows/UpdateImports.md
# Update Imports Workflow

This page discusses how to update the contents of your imports, like adding or removing terms. If you are looking to customise imports, like changing the module type, see [here](RepoManagement.md).

## Importing a new term

Importing a new term is split into to sub-phases:

1. Declaring the terms to be imported
2. Refreshing imports dynamically

### Declaring terms to be imported
There are three ways to declare terms that are to be imported from an external ontology. Choose the appropriate one for your particular scenario (all three can be used in parallel if need be):

1. Protege-based declaration
2. Using term files
3. Using the custom import template

#### Protege-based declaration

This workflow is to be avoided, but may be appropriate if the editor _does not have access to the ODK docker container_.

1. Open your ontology (edit file) in Protege (5.5+).
1. Select 'owl:Thing'
1. Add a new class as usual.
1. Paste the _full iri_ in the 'Name:' field, for example, http://purl.obolibrary.org/obo/CHEBI_50906.
1. Click 'OK'

<img src="https://raw.githubusercontent.com/INCATools/ontology-development-kit/master/docs/img/AddingClasses.png" alt="Adding Classes" />

Now you can use this term for example to construct logical definitions. The next time the imports are refreshed (see how to refresh [here](#Refresh-imports)), the metadata (labels, definitions, etc) for this term are imported from the respective external source ontology and becomes visible in your ontology.


#### Using term files

Every import has, by default a term file associated with it, which can be found in the imports directory. For example, if you have a GO import in `src/ontology/go_import.owl`, you will also have an associated term file `src/ontology/go_terms.txt`. You can add terms in there simply as a list:

```
GO:0008150
GO:0008151
```

Now you can run the [refresh imports workflow](#Refresh-imports)) and the two terms will be imported.

#### Using the custom import template 

This workflow is appropriate if:

1. You prefer to manage all your imported terms in a single file (rather than multiple files like in the "Using term files" workflow above).
2. You wish to augment your imported ontologies with additional information. This requires a cautionary discussion.

To enable this workflow, you add the following to your ODK config file (`src/ontology/{{ project.id }}-odk.yaml`), and [update the repository](RepoManagement.md):

```
use_custom_import_module: TRUE
```

Now you can manage your imported terms directly in the custom external terms template, which is located at `src/templates/external_import.owl`. Note that this file is a [ROBOT template](http://robot.obolibrary.org/template), and can, in principle, be extended to include any axioms you like. Before extending the template, however, read the following carefully.

The main purpose of the custom import template is to enable the management off all terms to be imported in a centralised place. To enable that, you do not have to do anything other than maintaining the template. So if you, say current import `APOLLO_SV:00000480`, and you wish to import `APOLLO_SV:00000532`, you simply add a row like this:

```
ID	Entity Type
ID	TYPE
APOLLO_SV:00000480	owl:Class
APOLLO_SV:00000532	owl:Class
```

When the imports are refreshed [see imports refresh workflow](#Refresh-imports), the term(s) will simply be imported from the configured ontologies.

Now, if you wish to extent the Makefile (which is beyond these instructions) and add, say, synonyms to the imported terms, you can do that, but you need to (a) preserve the `ID` and `ENTITY` columns and (b) ensure that the ROBOT template is valid otherwise, [see here](http://robot.obolibrary.org/template).

_WARNING_. Note that doing this is a _widespread antipattern_ (see related [issue](https://github.com/OBOFoundry/OBOFoundry.github.io/issues/1443)). You should not change the axioms of terms that do not belong into your ontology unless necessary - such changes should always be pushed into the ontology where they belong. However, since people are doing it, whether the OBO Foundry likes it or not, at least using the _custom imports module_ as described here localises the changes to a single simple template and ensures that none of the annotations added this way are merged into the [base file](https://github.com/INCATools/ontology-development-kit/blob/master/docs/ReleaseArtefacts.md#release-artefact-1-base-required).  

### Refresh imports

If you want to refresh the import yourself (this may be necessary to pass the travis tests), and you have the ODK installed, you can do the following (using go as an example):

First, you navigate in your terminal to the ontology directory (underneath src in your hpo root directory). 
```
cd src/ontology
```

Then, you regenerate the import that will now include any new terms you have added.

```
sh run.sh make PAT=false imports/go_import.owl -B
```

Since ODK 1.2.27, it is also possible to simply run the following, which is the same as the above:

```
sh run.sh make refresh-go
```

Note that in case you changed the defaults, you need to add `IMP=true` and/or `MIR=true` to the command below:

```
sh run.sh make IMP=true MIR=true PAT=false imports/go_import.owl -B
```

If you wish to skip refreshing the mirror, i.e. skip downloading the latest version of the source ontology for your import (e.g. `go.owl` for your go import) you can set `MIR=false` instead, which will do the exact same thing as the above, but is easier to remember:

```
sh run.sh make IMP=true MIR=false PAT=false imports/go_import.owl -B
```
^^^ docs/odk-workflows/ManageDocumentation.md
# Updating the Documentation

The documentation for {{ project.id.upper() }} is managed in two places (relative to the repository root):

1. The `docs` directory contains all the files that pertain to the content of the documentation (more below)
2. the `mkdocs.yaml` file cotains the documentation config, in particular its navigation bar and theme.

The documentation is hosted using github pages, on a special branch of the repository (called `gh-pages`). It is important that this branch is never deleted - it contains all the files GitHub pages needs to render and deploy the site. It is also important to note that _the gh-pages branch should never be edited manually_. All changes to the docs happen inside the `docs` directory on the `main` branch.

## Editing the docs

### Changing content
All the documentation is contained in the `docs` directory, and is managed in _Markdown_. Markdown is a very simple and convenient way to produce text documents with formatting instructions, and is very easy to learn - it is also used, for example, in GitHub issues. This is a normal editing workflow:

1. Open the `.md` file you want to change in an editor of choice (a simple text editor is often best). _IMPORTANT_: Do not edit any files in the `docs/odk-workflows/` directory. These files are managed by the ODK system and will be overwritten when the repository is upgraded! If you wish to change these files, make an issue on the [ODK issue tracker](https://github.com/INCATools/ontology-development-kit/issues).
2. Perform the edit and save the file
3. Commit the file to a branch, and create a pull request as usual. 
4. If your development team likes your changes, merge the docs into master.
5. Deploy the documentation (see below)

## Deploy the documentation

The documentation is _not_ automatically updated from the Markdown, and needs to be deployed deliberately. To do this, perform the following steps:

1. In your terminal, navigate to the edit directory of your ontology, e.g.:
   ```
   cd {{ project.id }}/src/ontology
   ```
2. Now you are ready to build the docs as follows:
   ```
   sh run.sh make update_docs
   ```
   [Mkdocs](https://www.mkdocs.org/) now sets off to build the site from the markdown pages. You will be asked to
    - Enter your username
    - Enter your password (see [here](https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token) for using GitHub access tokens instead)
      _IMPORTANT_: Using password based authentication will be deprecated this year (2021). Make sure you read up on [personal access tokens](https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token) if that happens!

   If everything was successful, you will see a message similar to this one:

   ```
   INFO    -  Your documentation should shortly be available at: https://{{ project.github_org }}.github.io/{{ project.repo }}/ 
   ```
3. Just to double check, you can now navigate to your documentation pages (usually https://{{ project.github_org }}.github.io/{{ project.repo }}/). 
   Just make sure you give GitHub 2-5 minutes to build the pages!

^^^ mkdocs.yaml
site_name: {{ project.title }}
theme: readthedocs
nav:
  - Getting started: index.md
  - Cite: cite.md
  - History: history.md
  - How-to guides:
      - Standard ODK workflows:
          - Overview: odk-workflows/index.md
          - Editors Workflow: odk-workflows/EditorsWorkflow.md
          - Release Workflow: odk-workflows/ReleaseWorkflow.md
          - Manage your ODK Repository: odk-workflows/RepoManagement.md
          - Setting up Docker for ODK: odk-workflows/SettingUpDockerForODK.md
          - Imports management: odk-workflows/UpdateImports.md
          - Managing the documentation: odk-workflows/ManageDocumentation.md
          - Continuous Integration: odk-workflows/ContinuousIntegration.md
          - Your ODK Repository Overview: odk-workflows/RepositoryFileStructure.md 
      - Contributing: contributing.md
{% if project.use_dosdps %}  - Design Patterns:
    - Design Patterns Overview: design-patterns.md
{% endif -%}
{% endif -%}
